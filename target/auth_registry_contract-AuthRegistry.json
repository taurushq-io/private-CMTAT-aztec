{"transpiled":true,"noir_version":"0.32.0+92ff2fa2e944722e5c3fa43fb3363f093b8f1d12","name":"AuthRegistry","functions":[{"name":"consume","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"5d3vbpzXcYDxe9Fnozgzc+ZfbqUoCidxCgOGHMROgcLwvXfZcpcUtBKJsRzx8fkW2+ddzhEGfl6T0i+/vPvrd3/+53/95/fv//bjT+/+9O+/vPvhx798+/P3P76//NUv79a/if7f3/3p79++f/gbP/387T9+fvcnadFv3n33/q8P/3Pnr9+8+9v3P3z37k/uv37z0eG2ejzbVbej4nHnrPi6fe7TWc1973N9+fWDPfbT6Yevcud0XD95rWeH89f/+ObhnnbIPfch9/RD7hmH3DMPuWefcU9dh9xTDrnnIe8Jesh7gu5D7nnIe4Ie8p6gh7wnaB1yz0Peh+y3vw/JCrseFl0v3PR6z/X5D811/cVL9aePDH8cW5ljG3PszRzbmWMHc+xkjl3MsRs59mbmZgtzbGYlN7OSm1nJzazkZlZyMyu5mZXczEo6s5LOrKQzK+nMSjqzks6spDMr6cxKOrOSzqxkMCsZzEoGs5LBrGQwKxnMSgazksGsZDArGcxKJrOSyaxkMiuZzEoms5LJrGQyK5nMSiazksmsZDErWcxKFrOSxaxkMStZzEoWs5LFrGQxK1nMSjazks2sZDMr2cxKNrOSzaxkMyvZzEo2s5LNrKQsZiZlMTspixlKWcxSymKmUhazlZevCZ2bWUtZzFzKgvZSoL0UaC8F2kuB9vIL2EdfZ25oLwXaS4H2UqC9FGgvFdpLhfZSob1UaC+/gAH0deaG9lKhvVRoLxXaS4X2EmrciEF7CcV5BKrzCJTnEajPI1CgR6BCj0CJHoEaPQJFegSq9AiU6RGo0yNQqEegUo9AqR6BWj0CxXoEqvUIlOsRqNcjULBHoGKPQMkegZo9AkV7BKr2CJTtEajbI1C4R6Byj0DpHoHaPQLFewSq9wiU7xGo3yNQwEeggo9ACR+BGj4CRXwEqvgIlPERqOMjUMhHoJKPQCkfgVo+AsV8BKr5CJTzEajnI1DQR6Cij0BJH4GaPgJFfQSq+giU9RGo6yNQ2Eegso9AaR+B2j4CxX0EqvsIlPcRqO+jUN9Hob6PQn0fhfo+upi9VKjvo1DfR6G+j0J9H4X6Pgr1fRTq+yjU91Go76NQ30ehvo9CfR+F+j4K9X0U6vso1PdRqO+jUN9Hob6PQn0fhfo+CvV9FOr7KNT3Uajvo1DfR6G+j0J9H4X6Pgr1fRTq+yjU91Go76NQ30ehvo9CfR+F+j4K9X0U6vso1PdRqO+jUN9Hob6PQn0fhfo+CvV9FOr7KNT3Uajvo1DfR6G+j0J9H4X6Pgr1fRTq+yjU91Go76NQ30ehvo9CfR+F+j4K9X0U6vso1PdRqO+jUN9Hob6PQn0fhfo+CvV9FOr7KNT3Uajvo1DfR6G+j0J9H4X6Pgr1fRTq+yjU91Go76NQ30ehvo9CfR+F+j4K9X0U6vso1PdRqO+jUN9Hob6PQn0fhfo+CvV9FOr7GNT3MajvY1Dfx6C+jy1mLw3q+xjU9zGo72NQ38egvo9BfR+D+j4G9X0M6vsY1PcxqO9jUN/HoL6PQX0fg/o+BvV9DOr7GNT3MajvY6/wfXy/MLesvM3t8sEX+fi0e11Pe6jeTtfdw9tuh3fY5w9Xejwerlry/PDjXf2gu8ZBd82D7loH3bX/5XdNfbrrC+O79e2qdTuqmY/Tv0I6esvTC3p6RU9v6Ok3enqHTP/wUvjx9IWenvLv+7vTf0KOqfbb9GnPp398zGaP7dljPnssZo/l7LGaPdajxz4hRrz4mMwem22Jz7bEZ1visy3x2Zb4bEt8tiU+25KYbUnMtiRmWxKzLYnZlsRsS2K2JTHbkphtScy2JGdbkrMtydmW5GxLcrYlOduSnG1JzrYkZ1uSsy2p2ZbUbEtqtiU125KabUnNtqRmW1KzLanZltRsS3q2JT3bkp5tSc+2pGdb0rMt6dmW9GxLerYlPdqSvdbsMZk9prPHbPbYnj3ms8di9ljOHqvZY7MtkdmWyGxLZLYlMtsSmW2JzLZEZlsisy2R2ZbIbEt0tiU62xKdbYnOtkRnW6KzLdHZluhsS+7/TEjXvj6mK/zXz37fbO+6fndr7376QfXd74RFyPWnzxHPfqpct4H6/kDZt4H6hR+G75LbQKX9wkDVch2oV3080P2fxajI9TEVrZcGKrsN1C/8HCza7TZQ9J2B5P6v0LLbQKGfH0iXP42/Ip/9RoC6c7x9XdehPZ6+jap1//T1R3Oy1rPDeZ1f4fMbfP4Nn9/h8wd8/oTPX/D5mz3//f9bCtD88P5ueH83vL8b3t8N7++G93fD+7vh/d3w/jq8vw7vr8P76/D+Ory/93+Hjcrt+1iq9sL8bdc/2dH19L2r+39YRHzdvoP4/Hc97t//onHKRfOUi9YpF+1DLhrrlIvqKRe1Uy66T7noKS8MccoLQ5zywhCnvDDEKS8MecoLw/3fmP1HvOhvfzP6XfgCf/qNHevDX73HuQ0694bO7dC5Azp3Qucu6NzNnLsWdG6Bzg3tZUF7WdBeFrSXBe1lQXtZ0F4WtJcN7WVDe9nQXja0lw3tZUN72dBeNrSXDe1lM3vpi9lLX8xe+mL20hezl76YvfTF7KUvZi99MXvpi9lLX9BeCrSXAu2lQHsp0F4KtJcC7aVAeynQXgq0lwLtpUJ7qdBeKrSXCu2lQnup0F4qtJcK7aVCe6nQXhq0lwbtpUF7adBeGrSXBu2lQXtp0F4atJcG7eWG9nJDe7mhvdzQXm5oLze0lxvayw3t5Yb2ckN76dBeOrSXDu2lQ3vp0F46tJcO7aVDe+nQXjq0lwHtZUB7GdBeBrSXX8BZ+jpzQ3sZ0F4GtJcB7WVAe5nQXia0l1Dfx6G+j0N9H4f6Pg71fRzq+zjU93Go7+NQ38ehvo9DfR+H+j4O9X0c6vs41PdxqO/jUN/Hob6PQ30fh/o+DvV9HOr7ONT3cajv41Dfx6G+j0N9H4f6PgH1fQLq+wTU9wmo7xOL2cuA+j4B9X0C6vsE1PcJqO8TUN8noL5PQH2fgPo+AfV9Aur7BNT3CajvE1DfJ6C+T0B9n4D6PgH1fQLq+wTU9wmo7xNQ3yegvk9AfZ+A+j4B9X0C6vsE1PcJqO8TUN8noL5PQH2fgPo+AfV9Aur7BNT3CajvE1DfJ6C+T0B9n4D6PgH1fQLq+wTU9wmo7xNQ3yegvk9AfZ+A+j4B9X0C6vsE1PcJqO8TUN8noL5PQH2fgPo+AfV9Aur7BNT3CajvE1DfJ6C+T0B9n4D6PgH1fQLq+wTU9wmo7xNQ3yegvk9AfZ+A+j4B9X0C6vsE1PcJqO8TUN8noL5PQH2fgPo+AfV9Aur7BNT3CajvE1DfJ6C+T0B9n4D6PgH1fQLq+wTU9wmo7xNQ3yegvk9CfZ+E+j4J9X0S6vvkYvYyob5PQn2fhPo+CfV9Eur7JNT3Sajvk1DfJ6G+T0J9n4T6Pgn1fRLq+yTU90mo75NQ3yehvk9CfZ+E+j4J9X0S6vsk1PdJqO+TUN8nob5PQn2fhPo+CfV9Eur7JNT3Sajvk1DfJ6G+T0J9n4T6Pgn1fRLq+yTU90mo75Ov8H12f/5LtNXj2a56YWrx69zST2c1973P9eXXD/bYT6cfvsqd03H95LWeHc7rRf2Ui8YpF81TLlqnXLQPuegrFKQ/yEXllIvqKRe1Uy66T7noKW9GfsqbkZ/yZuSnvBn5b38z+l3+8zLX9Vfv8hO/p48Mf5w7FnRugc6t0LkNOveGzu3QuQM6d0LnLujc0F4mtJcJ7WVCe5nQXr6Cr3qbc0N7mdBeJrSXCe1lQntZ0F4WtJcF7WVBe/kKvuptzg3tZUF7WdBeFrSXBe1lQ3vZ0F42tJcN7eUr+Kq3OTe0lw3tZUN72dBeNrOXtZi9rMXsZS1mL2sxe1mL2ctazF7WYvayFrOXtZi9rAXtpUB7KdBeCrSXAu3lK/iqtzk3tJcC7aVAeynQXgq0lwrtpUJ7qdBeKrSXr+Cr3ubc0F4qtJcK7aVCe6nQXhq0lwbtpUF7adBevoKveptzQ3tp0F4atJcG7aVBe7mhvdzQXm5oLze0l1+Ar/o6c0N7uaG93NBebmgvN7SXDu2lQ3vp0F46tJdfADX6OnNDe+nQXjq0lw7tJdT3KajvU1Dfp6C+T0F9n4L6PgX1fQrq+xTU9ymo71NQ36egvk9BfZ+C+j4F9X0K6vsU1PcpqO9TUN+noL5PQX2fgvo+BfV9Cur7FNT3KajvU1Dfp6C+T0F9n4L6PgX1fQrq+xTU9ymo71NQ36egvk9BfZ+C+j4F9X0K6vsU1PdpqO/TUN+nob5PQ32fXsxeNtT3aajv01Dfp6G+T0N9n4b6Pg31fRrq+zTU92mo79NQ36ehvk9DfZ+G+j4N9X0a6vs01PdpqO/TUN+nob5PQ32fhvo+DfV9Gur7NNT3aajv01Dfp6G+T0N9n4b6Pg31fRrq+zTU92mo79NQ36ehvk9DfZ+G+j4N9X0a6vs01PdpqO/TUN+nob5PQ32fhvo+DfV9Gur7NNT3aajv01Dfp6G+T0N9n4b6Pg31fRrq+zTU92mo79NQ36ehvk9DfZ+G+j4N9X0a6vs01PdpqO/TUN+nob5PQ32fhvo+DfV9Gur7NNT3aajv01Dfp6G+T0N9n4b6Pg31fRrq+zTU92mo79NQ36ehvk9DfZ+G+j4N9X0a6vs01PdpqO/TUN+nob5PQ32fhvo+DfV9ZEGBn8vgzGJeBmcm8zI4s5mXwZnRvAzOrOZlcGY2L4Mzu3kZnBnOy+DUckKpn8vg1HJCsZ/L4NRyQrmfy+DUckLBn8vg1HJCyZ/L4NRyQtGfy+DUckLZn8vg1HJC4Z/L4NRyQumfy+DUckLxn8vg1HJC+Z/L4C+X8+Hrf3ZwWXkb3OWDr/Lxafe6nvZQvZ2uu4e33Q7vsM8frvR4PFy15Pnh62X1pMvaSZfdJ13WT7ps/Msvm/p02Rfmd+vbXet2VDNv4yd7/GKP3+jxX4EkvenxhT2+QsZ/NsXz8Z09PuXf+58Y//6/eTSuE6nJB+/uj899wnl5+TkZPqfD52z43B4+58PnYvhcDp+r4XPDfYnhvsRwX2K4LzHclxjuSwz3JYb7EsN9ieG+xHBfcrgvOdyXHO5LDvclh/uSw33J4b7kcF9yuC853Jca7ksN96WG+1LDfanhvtRwX2q4LzXclxruSw33pYf70sN96eG+9HBfergvPdyXHu5LD/elh/vSs32RtYbPyfA5HT5nw+f28DkfPhfD53L4XA2fG+6LDPdFhvsiw32R4b7IcF9kuC8y3BcZ7osM90WG+6LDfdHhvuhwX3S4LzrcFx3uiw73RYf7osN90eG+2HBfPvFzVNPbt6ss9NfPfruq7fqz2q6nb0je//Gv+PUHwNLPv3m5732uL79+sMd+Ov3wVe6cvv5A5uHPZzz76NtN9Zib2jE33cfc1I+5aRxz0zzmpnXMTfuUm37ih7x/xJse8460j3lH2se8I+1j3pH2Me9I+7e/I/0uv23Xb7/LIdaHv3zXwZM6eFEHb+jgvqiDC3VwpQ5u1ME3dXCnDk4tp1PL6dRyOrWcQS1nUMsZ1HIGtZxBLWdQyxnUcga1nEEtZ1DLmdRyJrWcSS1nUsuZ1HImtZxJLWdSy5nUcia1nEUtZ1HLWdRyFrWcRS1nUctZ1HIWtZxFLWdRy9nUcja1nE0tZ1PL2dRyNrWcTS1nU8vZ1HI2tJy6oOXUBS2nLmg5dUHLqQtaTl3QcuqCllMXtJy6oOXURS2nUMsp1HIKtZxCLadQyynUcgq1nEItp1DLKdRyKrWcSi2nUsup1HIqtZxKLadSy6nUciq1nEotp1HLadRyGrWcRi3nF/CovtLg1HIatZxGLadRy2nUcm5qOTe1nJtazk0t5xdQir7S4NRyUg0hpRpCSjWElGoIKdUQUqohpFRDSKmGkFINIaUaQko1hJRqCCnVEFKqIaRUQ0iphpBSDSGlGkJKNYSUaggp1RBSqiGkVENIqYaQUg0hpRpCSjWElGoIKdUQUqohpFRDSKmGkFINIaUaQko1hJRqCCnVEFKqIaRUQ0iphpBSDSGlGkJKNYSUaggp1RBSqiGkVENIqYaQUg0hpRpCSjWElGoIKdUQUqohZFRDyKiGkFENIaMaQrag5TSqIWRUQ8iohpBRDSGjGkJGNYSMaggZ1RAyqiFkVEPIqIaQUQ0hoxpCRjWEjGoIGdUQMqohZFRDyKiGkFENIaMaQkY1hIxqCBnVEDKqIWRUQ8iohpBRDSGjGkJGNYSMaggZ1RAyqiFkVEPIqIaQUQ0hoxpCRjWEjGoIGdUQMqohZFRDyKiGkFENIaMaQkY1hIxqCBnVEDKqIWRUQ8iohpBRDSGjGkJGNYSMaggZ1RAyqiFkVEPIqIaQUQ0hoxpCRjWEjGoIGdUQMqohZFRDyKiGkFENIaMaQkY1hIxqCBnVEDKqIWRUQ8iohpBRDSGjGkJGNYSMaggZ1RAyqiFkVEPIqIaQUQ0hoxpCRjWEjGoIGdUQMqohZFRDyKiGkFENIaMaQkY1hIxqCG2qIbSphtCmGkKbagjtBS3nphpCm2oIbaohtKmG0KYaQptqCG2qIbSphtCmGkKbaghtqiG0qYbQphpC+xWGUPbnv0ZbPZ7tqhfGFr8OLv10VnPf+1xffv1gj/10+uGr3Dkd109e69nhvN20T7npK5SiP8pN5Zib6jE3tWNuuo+5qR9z0zjmpnnMTY95R9Jj3pHsmHckO+YdyY55R7Lf/o70u/znZq7rL1+qP31k+G3wTR3cqYMHdfCkDl7UwRs6+F7UwYU6uFIHp5bzFUTWGx2cWs5NLeemlnNTy7mp5XRqOZ1aTqeW06nlfAWR9UYHp5bTqeV0ajmdWk6nljOo5QxqOYNazqCW8xVE1hsdnFrOoJYzqOUMajmDWs6kljOp5UxqOZNazlcQWW90cGo5k1rOpJYzqeVMajmLWs6ilrOo5SxqOV9BZL3RwanlLGo5i1rOopazqOVsajmbWs6mlrOp5XwFkfVGB6eWs6nlbGo5m1rOhpbTF7ScvqDl9AUtpy9oOX1By+kLWk5f0HL6gpbTF7ScvqjlFGo5hVpOoZZTqOV8BZH1RgenllOo5RRqOYVaTqGWU6nlVGo5lVpOpZbzC+BPX2lwajmVWk6lllOp5VRqOY1aTqOW06jlpBpCTjWEnGoIOdUQcqoh5FRDyKmGkFMNIacaQk41hJxqCDnVEHKqIeRUQ8iphpBTDSGnGkJONYScagg51RByqiHkVEPIqYaQUw0hpxpCTjWEnGoIOdUQcqoh5FRDyKmGkFMNIacaQk41hJxqCDnVEHKqIeRUQ8iphpBTDSGnGkJONYScagg51RByqiHkVEPIqYaQUw0hpxpCTjWEnGoIOdUQcqoh5FRDyKmGkFMNIacaQk41hJxqCDnVEHKqIeRUQ8iphpBTDSGnGkJONYScaggF1RAKqiEUVEMoqIZQLGg5g2oIBdUQCqohFFRDKKiGUFANoaAaQkE1hIJqCAXVEAqqIRRUQyiohlBQDaGgGkJBNYSCaggF1RAKqiEUVEMoqIZQUA2hoBpCQTWEgmoIBdUQCqohFFRDKKiGUFANoaAaQkE1hIJqCAXVEAqqIRRUQyiohlBQDaGgGkJBNYSCaggF1RAKqiEUVEMoqIZQUA2hoBpCQTWEgmoIBdUQCqohFFRDKKiGUFANoaAaQkE1hIJqCAXVEAqqIRRUQyiohlBQDaGgGkJBNYSCaggF1RAKqiEUVEMoqIZQUA2hoBpCQTWEgmoIBdUQCqohFFRDKKiGUFANoaAaQkE1hIJqCAXVEAqqIRRUQyiohlBQDaGgGkJBNYSCaggF1RAKqiEUVEMoqIZQUA2hoBpCSTWEkmoIJdUQSqohlAtaznyFIdT6wuDa18Ni2z74Kh+f9qrraW+L2+m6ezhNr4cz8vOHq9ofD1fbB4evl42TLpsnXbZOumwfdNlXOEp/oMvKSZfVky5rJ112H3HZy1/897f/+P7bP//w3U+XRx7+2T/f/+Xn7398//iXP//P3///n1zO/i8="},{"name":"set_authorized_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"function_data","type":{"fields":[{"name":"selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_private","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_data::FunctionData"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"caller_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::caller_context::CallerContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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LxV8oKq6WisvtVWraq28VPBRuepqrbzUZuWlgk9BFlcbfAiyulorLxV8BLK6WisvFXwAsrpaKy8VfPyxulorLxV8+LG6WisvFXz0sbpaKy8VfEyyulorLxV8pLK6WisvFXygsrpaKy8VfJyyulonLzUFn6WsrtbJS03B5yirq3XyUh+1WFXr5KWm4POT1dU6eakp+OxkdbVWXir43GR1tVZeKvjMZHW1Vl4q+LxkdbVWXir4rGR1tVZeKvicZHW1Vl4q+IxkdbVWXir4fGR1tVZeKvhsZHW1Vl4q+FxkdbVWXir4TGR1tVZeKvg8ZHW1Vl4q+CxkdbVWXir4HGR1tVZearbyUrOVlwo+31pdrZWXqlZeqlp5qeBzy9XVWnmp4DPL1dVaeang88rV1Vp5qeCzytXVWnmp4HPK1dVaeangM8rV1Vp5qeDzydXVWnkpq7nnk9Xc88lq7vlkNfd8spp7PlnNPZ+s5p5PVnPPJ6u555PV3PPJau75ZDX3fLKaez5ZzT2frOaeT1ZzzyerueeT1dzzyWru+WQ193yymns+Wc09n6zmnk9Wc88nq7nnk9Xc88lq7vlkNfd8spp7PlnNPZ+s5p5PVnPPJ6u555PV3PPJau75ZDX3fLKaez5ZzT2frOaeT1ZzzyerueeT1dzzyWru+WQ197xYzT0vVnPPi9Xc82I197w8qlW1Tl6qWM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz4vV3PNiNfe8WM09L1Zzz2erueez1dzz2Wru+Ww193x+VKtq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d+yoN5Uf7Kg3lcfrqDeVb2vXe6TyYh31mvmrw8xfHWb+6qhm9Zr5q8PMXx1m/uow81eHl7/aHl7+ant4+avt4eWvtoeXv9oe1axeL3+1Pbz81fbw8lfbw8tfbQ8zfzWZ+atc++k76jXzV7n2sXfUW83qNfNXufZ+d9Rr5q9y7bnuqNfMX+Xa69xRr5m/yrXHuKNeM3+Va29vR71m/irXntqOes38Va69rB31mvmrXHtIO+o181e59m521Gvmr3Ltmeyo18xf5dqr2FGvmb/KtUewo14zf5Vrb15HvWb+KteeuI56zfxVrr1oHfWa+atce8A66jXzV7n2XnXUa+avcu156qjXzF/l2mvUUa+Zv8q1x6ejXjN/lWtvTUe9Zv4q156WjnrN/FWuvSQd9Zr5q1x7ODrqNfNXufZOdNRr5q9y7VnoqNfMX+XaK9BRr5m/yjWjv6NeM3+Va5Z+R71m/irXzPuOes38Va7Z9B31mvmrXDPkO+o181e5Zr131Gvmr8zmt29m89s3s/ntm9n89s1sfvtmNr99M5vfvpnNb9/M5rdvZvPbN7P57ZvZ/PbNbH77Zja/fTOb376ZzW/fzOa3b2bz23ez+e272fz23Wx++242v31/VLN6vfzVbja/fTeb376bzW/fzea372bz23ez+e272fz23Wx++242v303m9++m81v383mt+9m89t3s/ntu9n89t1sfvtuNr99N5vfvpvNb9/N5rfvZvPbd7P57bvZ/PbdbH77bja/fTeb376bzW/fzea372bz23ez+e272fz23Wx++242v303m9++m81v383mt+9m89t3s/ntu9n89t1sfvtuNr99N5vfvpvNb9/N5rfvZvPbd7P57bvZ/PbdbH77bja/fTeb376bzW/fzea372bz23ez+e272fz23Wx++242v303m9++m81v383mt+9m89t3s/ntu9n89t1sfvtuNr99N5vfvpvNb9/N5rfvZvPbd7P57bvZ/PbdbH77bja/fTeb376bzW/fzea372bz23ez+e272fz23Wx++242v303m9++m81v383mt+9m89t3s/ntu9n89t1sfvtuNr99N5vfvpvNb9/N5rfvZvPbd7P57YfZ/PbDbH77YTa//TCb3348qlm9Xv7qMJvffpjNbz/M5rcfZvPbD7P57YfZ/PbDbH77YTa//TCb336YzW8/zOa3H2bz2w+z+e2H2fz2w2x++2E2v/0wm99+mM1vP8zmtx9m89sPs/nth9n89sNsfvthNr/9MJvffpjNbz/M5rcfZvPbD7P57YfZ/PbDbH77YTa//TCb336YzW8/zOa3H2bz2w+z+e2H2fz2w2x++2E2v/0wm99+mM1vP8zmtx9m89sPs/nth9n89sNsfvthNr/9MJvffpjNbz/M5rcfZvPbD7P57YfZ/PbDbH77YTa//TCb336YzW8/zOa3H2bz2w+z+e2H2fz2w2x++2E2v/0wm99+mM1vP8zmtx9m89sPs/nth9n89sNsfvthNr/9MJvffpjNbz/M5rcfZvPbD7P57YfZ/PbDbH77YTa//TCb336YzW8/zOa3H2bz2w+z+e2H2fz2w2x++2E2v/0wm99+mM1vP8zmtx9m89sPs/nth9f89u3hNb/9o14rf/VRr5W/+qjXyl991FvN6rXyVx/1Wvmrj3qt/NVHvVb+6qNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeM3/lNb/9o14zf+U1v/2jXjN/5TW//aNeL381mc1vn8zmt09m89sns/ntHy8xq9fLX01m89sns/ntk9n89slsfvtkNr99MpvfPpnNb5/M5rdPZvPbJ7P57ZPZ/PbJbH77ZDa/fTKb3z6ZzW+fzOa3T2bz2yez+e2T2fz2yWx++2Q2v30ym98+mc1vn8zmt09m89sns/ntk9n89slsfvtkNr99MpvfPpnNb5/M5rdPZvPbJ7P57ZPZ/PbJbH77ZDa/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"},{"name":"is_consumable","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/+2aWU8jRxDH2xchju1hbGxsbMCA72MwxrAoWfYxT3mLFClPUW5FyiHlUJSvmE+VrqquqRkGzapWmxZa7UiD29X/X9fRY3tKw8iUjNmvGHucGHeUrcU0zJ59KcD5yvDIDor2LDRMgU1jmASqOHYyU8IRCMs4sh5M5cL+qY0NrbBfvoWJMqw1MgWAPqgYZGFoz70RDnf2rI45sH2ah6MKf0gD2IcjmbELfmpfPyLxvhPXxkUymppgNdJUaYjoX2JmtI4oCOqC1gWtO/RXMTPaQBQEDUEbgjYc+q2YGQ0QBUEgaCBo4NA/xczoAaIgOBD0QNADh/4kZkZDREEQChoKGjr0NzEz2kQUBE1Bm4I26TWL1PMR620oZkZbiIKgJWhL0FbWWyvOLQex3v4QM6OHiILgUNBDQQ8d+pWYGW0jCoK2oG1B29lA2/HWK5FQj9T1SEuP1PIRW7lfxMxoB1EQdATtCNpx6NdiZvQIURAcCXok6JFDvxEzo11EQdAVtCto16E/i5nRHqIg6AnaE7Tn0O/FzOgxoiA4FvRY0ONsZY/jT4ASaeiRjh6pe8kl9BJYNx+xW/qPmBntIwqCvqB9QftZb/24DErkSI/0vATW0CMdPdL1grymYvYq+E7MjA4QBcFA0IGgg6y3QVxsJdLSI4Ee6XjxcqBHGl5y6XpBjvORc7DX5T75FkEjN8d8NwxqM+Y7Zrti2chxgq5O0q5OCR7QkGfgRvxUREO53z7fw+G501+4+/nLAgovwQQnRlyld5wu2C7HLDsTxzRRJCNMsochvA4hhkRYjwK+K7hsb0mDOca1KUltTtI9xJ7kdDIyFZM+YJUBNkXoyW1IyS1TxWAH9DXAC1YT8/SaRcr5SCokTub0k3JCU6KdeRwvHGcUL9TwrILDqntbHqE7c05dV5nLS05eQl3iil1IxUbpil1KeCO74Od0qZXcloN4gknCUhPBJqQZ0RBes0igR8J8xAb4u5gZnSIKgqmgU0GnWW/T+JsjB7HefhQzozNEQTATdCboLOttFv/0KJGmHmnpka4eCfVI8NbTt/uzETOjc0RBMBd0Lug8620ee1MidT0S6pHASy4dPdL1grymYvYq+FvMjC4QBcFC0IWgi6y3RfwpVSL9fMQGGImZ0SWiIFgKuhR0mfW2jLdWiYz1SKBHQj0y0SMdPTLVIz0v+9LSI10v+xJ4yeUNKtbWIzUvuQTP9YIJvHzEJs+hYvaL9gcxM7pCFAQrQVeCrrLeVnFOSiTUI2090sxHbBmuxczoGlEQrAVdC7rOelvHP1E5CLQcxY+l73hA0Eizwd0FqKmLHdGKyS42QldR2tUVwWsa8gw0Nlciupb+ZUtd7Nbpb1wXu6MuFtrMGzgx4hf0jtMFZjdm2UYc00SRjDDJHqDE26FdKRnWo4Cxi4VsH6Txi+LalKU2kUn1ZInOPCJRmauDoVSf3JLIuX4SqeQjEt86bkwjt8ia2s7ItZ0Vajcrrt2sSvqbp7Z9k07tapSc4SsJRNfxrcp1YndJs3EFfxIJ9EioRyZ6pKNHpnqkp0eaeqSlR7pe9iXwkv7Mi5f6O1SxjpcLxs81NvfyqezrkYWXrXz/nfz+O/n/3v2Wl4q19UjNSy7Bc71gAi8fsclzrdjSSy6hlyv5DdJfvfWfJGgZSl9K3/CAoEm3BMapqV3c0IrJdnGLrrZpV66du6Yhz7ykTpBFt9J/3FG7eOf0L1y7eE/t4j2Y4MSIv6B3nC4w92OW7cQxTRTJCJPsAR7u3g3t+88SYT0KGNvFDbWLjx8FYstFjwJhqpJI+6lHxjfprms75fa6YFLPKm/24meVgOwwWfgPiB0G4w5+bA0y6ZKjRtwXVl85/3jKv5eSqRE/ttzSEDYuQiRyZwJB05gntzgCoHgJw+6/cP4H0PaWlvIqAAA=","debug_symbols":"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"},{"name":"unconstrained_is_consumable","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"set_reject_all","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"reject","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/83X2W7TQBQG4HGWkqZtSmLHseM4ieOlCxGCC5AQlBskXoAnQGK5YZFYxDvyVMw5M8d/gitXcxPV0sST4/PNnBk3qqZQXaUGuimVKntRRI3Ukb551F4r6elORzdvpDwJmbwONc7rmLabx6GSHtLopkdDdUsLVG+jP86eKSllTB/9girhgQal1HbE5fHFo5kcGu1BgSeF6qv9izKOuVZ1bFrXjMbDDMuOfTDEgEOTMzBdujdJv53slSSLOXnZ28mh8U6a9dJ1auo9pdbn7tB+1VtD06lRn++ER7SDZpJXtIP1jp1jx8b7O/YQ5Y31gO/0fWKSz22yz4ucUA/MNzlj02X6C2GhAVNKCEAD0MDS7wgLnTKlhCnoFHRq6Q+EhYZMKSEEDUFDS98jLHTGlBJmoDPQmaWfERYaMaWECDQCjSz9iLDQmCklxKAxaGzpGmGhc6aUMAedg84t/Ymw0IQpJSSgCWhi6ReEhS6YUsICdAG6MPcmCdyJ707idqLX9ARhoSlTSkhBU9C0OVtaz9ZC9GzfEBa6ZEoJS9Al6LI527LeQUfiu5PYnYTuJDkIuWPH9Pv5g7DQFVNKWIGuQFfN2Vb1r7iF6Nk+ICx0zZQS1qBr0LWljxEWmjGlhAw0A82ahWb1K3YkE3fiu5PAnUzdSehOZu4kOsh7mbuT5CDvxT/IWu7YMf27+Yqw0A1TStiAbkA3lv5GWGjOlBJy0Bw0bxaa12tzJL47ie9rYaE7md6HHdN/BZ8QFlowpYQCtAAtmrMV9ZocSeBOMncStxO9DU8RFloypYQStAQtm7OV9b+sFkL1e29xnrlhqHCIkVNLWX+MzYg9haviqar9qS4MLk1XntCB6QJJVzgXXR9x99rmP9IbQRlbjxO3FKLGFb8x32S5ZLalpF1iYvOgY4L0UGa4orveG+/FTln/Ffzcs6u9MYfDnqoPyh4vWpbfwzZV+8e+s2L3SdcOUtVvp3/r26lsFdWlZwUfeHOKRX+p/QNL3SAxSxAAAA==","debug_symbols":"5dzdalNRFEXhd8l1kT3n2r99FRGJWiVQUrFRkOK7m2hOU2mogqIM951tl8lavRmHFL671ZurVx/fvdxs397cri6f362ub16vd5ub7f6ru1V6pvj23dv36+3hG7e79Yfd6lIucbG62r45/LPFl4vV28311eqylC8Xj4Zz7uM4nPNo98P93HCtSsfhWl0eDr+4OOyTz+8TOu2Tn95nRD/Ojt7vR1XqmVmVZRuN0+y3t3j8uiWV5YVLPS3hw7ucma7LK6f0YLgd7yyT3FknubNNcmef5M4xx53WJHd6kjtjkjvzJHdO8pzgSZ4TPMlzgid5TvAkzwmRJrlzkueh+P3nIaV6/yGBnH5y6XJnevpFW1p+ee3BpwOqx48HIjPXLsy1K3Ptxly7M9ceyLVzYq4t5trM3ORgrs2sZGZWMjMrmZmVzMxKZmYlC7OShVnJwqxkYVayMCtZmJUszEoWZiULs5KFWcnKrGRlVrIyK1mZlazMSlZmJSuzkpVZycqsZGVWsjEr2ZiVbMxKNmYlG7OSjVnJxqxkY1ayMSvZmJXszEp2ZiU7s5KdWcnOrGRnVrIzK9mZlezMSnZmJQezkoNZycGs5GBWcjArOZiVHMxKDmYlB7OSg1lJJWYmlZidVGKGUolZSiVmKpWYrdy/J3RvZi2VmLlUgvZS0F4K2ktBeyloL/+ArvRv9ob2UtBeCtpLQXspaC8N7aWhvTS0l4b28g8oQ/9mb2gvDe2lob00tJeG9jKgvQxoL6HKjQLaSyjPI6jPIyjQI6jQIyjRI6jRIyjSI6jSIyjTI6jTIyjUI6jUIyjVI6jVIyjWI6jWIyjXI6jXIyjYI6jYIyjZI6jZIyjaI6jaIyjbI6jbIyjcI6jcIyjdI6jdIyjeI6jeIyjfI6jfIyjgI6jgIyjhI6jhIyjiI6jiIyjjI6jjIyjkI6jkIyjlI6jlIyjmI6jmIyjnI6jnIyjoI6joIyjpI6jpIyjqI6jqIyjrI6jrIyjsI6jsIyjtI6jtIyjuI6juIyjvI6jvY6jvY6jvY6jvY6jv48TspaG+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+j6G+T0B9n4D6PgH1fQLq+0Ri9jKgvk9AfZ+A+j4B9X0C6vsE1PcJqO8TUN8noL5PQH2fgPo+AfV9Aur7BNT3CajvE1DfJ6C+T0B9n4D6PgH1fQLq+8Qv+D69/2Tv/R9bluHI8cObPJ4uQ8tGZcRppX5uOO5fOafTb8+tLdu3v7197zptX5/evrTwMtxqe3q491GOw33ED8PHW/tEt455bv0Fgej/uVUT3eqJbo2Jbs0T3VomurVOcev+i0/rD5v1q+ur2/1/Ofzs4/b1bnOzPX65+/z++0/2s18B"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2b0W7aMBSGHRq6tGlTSAiBQgt0baXdpazt6N1eZnvuXU/aOwwHH/HXdZDRjmcsEQnFie3zf/6PbdIqRGJzJOtPpMpddT4VHw9q812d6387nhhj1S45o0A4O4FwngTCGTNyRgZOeY5VWa47ueY+ic16/FCJnWWiT6Be7AqkqyaqkGh1bKNd1W+nIIDwQsHHqo7Okfqkqh4BUzXYph3cowF34B5pncA92slIK1HmOBj3S7LF5o29no1yLGcqFvGnUMa6KVgYOxxr181Yn53laO2jwxw1q5zy0FWxE7imnJyDPuO3yxPqU+xzbX7EUJ5AW2pHbTrAK49LsV1L5zv6xVq/DNqcQr9E60fXlHfpV1+V5bmbbNtSfEc+1jJ26ib2uxzFmocpjC0Dfb45ulxJjQvx/oi0a/xiyYDp0gnTZk26Ge8ml1cQm+8p6eVZxutpvl1ovmXQ5gq87DnyMgJtYqLrXos+nyevKxmvb+FJ38DU9+BJv0Wf0ZM3GS+38CQ3MOUePMlb9Pk8+fZVxissPCkMTIUHT4oWfT5Pls3zw8DCk4GBaeDBk0GLPuPaaeZJaeFJaWAqPXhStugzevJTxhtaeDI0MA09eDJs0Wf05IeMV1l4UhmYKg+eVC36jHts83wysvBkZGAaefBk1KLP6MlSxhtbeDI2MI09eDJu0WdcO43+tYUn1wamaw+eoOY+3INAuatAuYsD4db1GddOs8dOLDyZGJgmHjxBzX24ywPh1vUZc/ki400tPJkamKYePEHNfbjzQLmLQLmHgXKXgXJXgXIfyvzW9Rmfv5s99sbCkxsD040HT1BzH+48UO5JoNzFgXDr+oxrp/n/4K2FJ7cGplsPnqDmPtyjQLn7B8Kt6zPOwVcZb2bhyczANPPgCWruwz0OlLsKlHsSKHcRKPcwUO4yUO7juvy/3PmBcMt79L7PH+dMy7dUYyINoXEKjTOFcgacc4jRZeOsa8zVHPQWTnzZ5EqfP3S9cK6/XMnYnx2NTca+dxO7+ZvjQcWidxrvDb49gn7EnLcHLTZpPUAuqfwb2lI7akP7BfHL99nuVPlxR7+Z1i+DNnfQ717rR9eUd+nfL1V2Odds5npPbNf5F2BytFc+4/vLAjSExknHDJjmbpieHI63xncaheBdjwvNszPNswza4F7uc289ch+5bbjxOeQM7lH9HO51tPHgb0UWEOMv7Ab1lOo2AAA=","debug_symbols":"ndpRattAGIXRveg5FN/fmhkpWymlOIlTDMEJiVMoJnuv3ZIF5LxpJN237+kw5+lhf/f+6+fh+Pj8Nt1+P09Pz/e70+H5eDmdp823Wv69fXvZHa8v3k6719N0u+3jZtofHy5Poz5upsfD0366be3jx811s359s93AJrAp2GxhM8OmwabDZsAGOthCBzN0MEMHM3QwQwczdDBDBzN0MEMHM3QwQwcNOmjQQYMOGnTQoIMGHTTooEEHDTpo0EGHDjp00KGDDh106KBDBx066NBBhw46dDCggwEdDOhgQAcDOhjQwYAOBnQwoIMBHSzQwQIdLNDBAh0s0MECHSzQwQIdLNDBAh2s0MEKHazQwQodrNDBCh2s0MEKHazQwQodZLORUWRUMtrKaJZRk1GX0ZDRIiMpIlJEpIhIEZEiIkVEiogUESkiUkSkiJIiSoooKaKkiJIiSoooKaKkCMHGiDZGuDHijRFwjIhjhBwj5hhBx4g6Rtgx4o4ReIzIY4QeI/YYwceIPkb4MeKPEYCMCGSEICMGGUHIiEJGGDLikBGIjEhkhCIjFhnByIhGRjgy4pERkIyIZIQkIyYZQcmISkZYMuKSEZiMyGSEJiM2GcHJiE5GeDLikxGgjAhlhCgjRhlByohSRpgy4pQRqIxIZYQqI1YZwcqIVka4MuKVEbCMiGWELCNmWWKWJWZZYpYlZlliliVmWWKWJWZZYpYlZlliliVmWWKWJWZZYpYlZlliliVmWWKWJWZZYpYlZlliliVmWWKWJWZZYpYlZll0QVLMssQsS8yyxCxLzLLELEvMsr5qlpfD793rYXf3tL9ehb1+ez/ef96MvRxPf17+f7n8+xc="},{"name":"is_reject_all","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/83Z6W7bRhAH8NVhx4olirpM6rJli7RuO3HsFmibfCnQF+gDFL3RogfQA0VfsU/Vndkd/iUToTFBQIQArdXs/Di7SynmOompGXNSN/aYGn9QxATm2L5U6HxjpGUbVXtWAlORUEqdpKqpTzM1blFi/cr+OE2Ncye1B+qo0RUSU6HU4yNTcRWpnDlKuHlvz0Yqw3nm+ulo0A+XQ+wkQY+94Bf29blLfuaTT9OqC5pTsFOX03BNpn8jLLTJlBKaoE3Qpqe/ISy0xZQSWqAt0Jan3yIsNGBKCQFoABp4+hfCQttMKaEN2gZte/oTwkJDppQQgoagoae/Iyy0w5QSOqAd0I57zZNmMbHVZggL7TKlhC5oF7Sbr9bN5lZAbLU/ERbaY0oJPdAeaM/TrxAW2mdKCX3QPmjf0z8QFjpgSgkD0AHowNPvERZ6xpQSzkDPQM88/RlhoRFTSohAI9Aov7JRVk1JWnoS6EmvmNhl+BphoTFTSohBY9DY018QFjpkSglD0CHoMD/QdyYdPWnpSaQnzVLmEpYysCfui/0U/Iuw0BFTShiBjkBH+WqjbBkKiK32DcJCx0wpYQw6Bh3nq42zb62SdPSkpSeRnsSlkCdWzN6f7xAWOmFKCRPQCegkX22SLbaSdPUk0JOolCptPWmVMpe4FDIsJpcUb+F5+YGhwUOyPBVTtknlydlesW5wTLnU9LDUucMT15QeeiA/R9IMz92Xx9y89PlX/rl+XuHEOYXo5BE/d+9kuhSbp5J2gcKuo+qC1CkVZvQ6ozHsDevRgD+q+Nk+uByeY7q3tZGRTw/3EkeY0zQxR+bw4LvAWyKu5G9IzV+mwYOduH8G5IKNvX73mif1YnIwJJnM+af1vZyauzOPx0vHhRsvreHFETcb/m094XLm0u2+6rK8rshntC7Zil1hxZLDFZtjeIm94Jfuo1bzt5ySr3mSdKlrsGuXk7gmveZJoCehnvT1JComdhl+RFjogiklLEAXoIt8tUX2K0dJOnrS1ZNYT0I9Cd779O39eYGw0CVTSliCLkGX+WrLrJqSNPUk1JOglLlEehKXQp5YMfsp+AdhoSumlLACXYGu8tVW2bdUScbFxA7wBmGha6aUsAZdg67z1dbZrVWSVE8CPQn1pK8nkZ5c68mglPvS1ZO4lPsSlDKXJ1bMfm9+RVjohiklbEA3oJt8tU32t18l6epJoCedD3VgkZ70P4QVsx+cHxAWumVKCVvQLeg2X22bzUlJQj1Z60mnmNhleImw0B1TStiB7kB3+Wq77FdVAaEtR/UT7DteMzTYbMjugrLdLjZxV9zfxd5wqZvDUrcO71xTemhjc4ukl9i/3Lld7J3Pf+V3sfduF0vbzFd08og/du9kumTuU0l7gcKuo+qC1CkVaInvZvZK+8N6NGDexdJsX2O82JPV37onmy2qfp/HG7s9fJxtLYnc8lQ+pxaX8kfNXZzTblO/kqYRZLvH+htfn0/8X6ALuTxqzlxzRoxJw597hEPZHydm3CJQnVMz/o/O/wEpfgJCnxwAAA==","debug_symbols":"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"},{"name":"set_authorized","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/+2Z227bRhCGV8faUeIkNilK1ImSSMmS6ti+aC/auFcF+gC96mXRJrnJAcgBecc8VXZmdviToaBgg4QwghCgSM7+38zsLCl5zNS0jDlqG7tNjNvs1ZE5MV17aND+h9Eze9K0e+PENNQkOnLSYl1L9qKOTRkNkvdm5twZsZGwnTnUdBb24+QXo0k9pI9uatTlcaZZ/mTYSNsxfYiG/B6lGElNx5Q38nKHszZ3ZG+JN3bTy5puoAeHPdEcyykdq0j3MFJKSSdz9/d2QUP+7lbzpe2e5HuP9o6Ecpe2NBTO3O/wkYbuUwUlyGO7n+YVe4CKnZYr9hDpnVqHf9vjmYgfOHHAkzyjM2CBaE7llNG3MCsaMkqCEGgINHToK5gV7TNKgj7QPtC+Q1/DrGjEKAkioBHQyKH/wqzogFESDIAOgA4c+gxmRYeMkmAIdAh06NAnMCsaM0qCGGgMNHZoArOiI0ZJMAI6Ajpy6BuYFR0zSoIx0DHQsUOfw6zohFESTIBOgE7kWEVCfyTwR+LDiJ3TFcyKThklwRToFOi0Gm2aRzuA2GgvYVZ0xigJZkBnQGfVaLO8gp5I4I/E/kjkj4xrQT5TMbs+72FWNGGUBAnQBGhSjZbkT/EBxEb7H2ZF54ySYA50DnTu0EcwK7pglAQLoAugi2qii3yJPZEzfyTwR0J/pO+PRP7IwB8Z1rIuI39kXMu6BLXM5TMVs8/NC5gVXTJKgiXQJdClQ9/BrGjKKAlSoCnQtJpoms/NEwn8kfi2Jhb5I/3bUDF7FzyFWdGMURJkQDOgWTVals/JEwn9kYU/Eh9GbBmuYVZ0xSgJVkBXQFfVaKv8J+sAQsONv9DP3DBo0MRo10Jqji9satoG25pDrcuhzgVeyamOUMN0DtEWfdGuy6c7p//ZFoIUFw0WXpCJds74T7nS6RJzkalsg8Ay0BQjDWqELR0T6+m3QlqfJPxrw832Bg3lOq9NF7VZl3u9k7Q40hKtVIdT6e1dkrULvRdpH0aQ3ypveNfOyaqT+6J2ttfR7pnb2Damv9m37Jvy1M7T4ojeSSTa5n+6bAurK5qNK/heJPBHQn+k749E/sjAHxn6I7E/MvJHxrWsS1DL9Ce1RJl+RxWLarlh6rnHZrU8lYk/Mq9lKX98J//4Tv7Wqz+qpWILf2RZy1yC23rDBLU8Yv3bWrG0lrmEtdzJXzD97Kv/JNFw8yn6hhsGTbklME4t7eJGPBbbxR2H2pVDuXZuK6c68lg6QRU9Qv9xKe3ipdNfuXbxWtpFaqHp7cMVZ/yfXOl0ibnOVHaBwDLQFCMNagT6j/BlYj39U0jrk4S5XaTZ3si7RHrNWHhfucvL1EGZduX2qp0WR1rOyS5fnd7e1cn72fOGI+i4XlLAwQfaPwJpU8mGhB4AAA==","debug_symbols":"5dzdah1XEoDRd9G1GbpqV+3u9qsMw6AkziAwcoiVgWDy7jlKdCSbCJ0Lk0Qrfaef7e4qYfi2bFifrr57981P//vvze33Hz5evf33p6v3H769vrv5cHv67NPV8q+o37768Yfr2/svfLy7/vHu6u3W/ebq3e13p4/W/uXN1fc3799dve3Th384WrXtD2er9vXx8Pbc4TljeTg8Z/bnh//z5n6afnaaXB+nmS9Ps4/t4ei+bY9Ho+czZ6PPs8T+dDbXeu65vZx/InvPejp9/5ZnTs/zk5fls8Prw5bzEFuuh9hyO8SW+xG2zOUQW+YhthyH2LIOseUhbgV5iFtBHuJWkIe4FeQhbgXjELeCEYfY8hB3n/G1d59Y5ji/IHK5sOd5y+Xlh/Ye51/9ly9/dL8P3eLQUxx6FYfexKF3cOhaxKFDHDrFocW4VIlDi0UssYglFrHEIpZYxBaL2GIRWyxii0VssYgtFrHFIrZYxBaL2GIRp1jEKRZxikWcYhGnWMQpFnGKRZxiEadYxCkWcRWLuIpFXMUirmIRV7GIq1jEVSziKhZxFYu4ikXcxCJuYhE3sYibWMRNLOImFnETi7iJRdzEIm5iEXexiLtYxF0s4i4WcReLuItF3MUi7mIRd7GIu1jEWMQkxiI2MRYxirGIVYxFzGIsYhdP7ySnFssYi5jGWMg2BtnGINsYZBuDbGOQbQyyjUG2Mcg2BtnGINuYZBuTbGOSbUyyjV8N+vw9U5NtTLKNSbYxyTYm2cZBtnGQbRxkG0kgJgbZRtK1CRK2CVK2CZK2CdK2CRK3CVK3CZK3CdK3CRK4CVK4CZK4CdK4CRK5CVK5CZK5CdK5CRK6CVK6CZK6CdK6CRK7CVK7CZK7CdK7CRK8CVK8CZK8CdK8CRK9CVK9CZK9CdK9CRK+CVK+CZK+CdK+CRK/CVK/CZK/CdK/CRLACVLACZLACdLACRLBCVLBCZLBCdLBCRLCCVLCCZLCCdLCCRLDCVLDCZLDCdLDCRLECVLECZLECdLECRLFCVLFCZLFCdLFSdLFSdLFSdLFSdLFyUVsY5IuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuTpIuziBdnEG6OIN0cQbp4oxFbOMgXZxBujiDdHEG6eIM0sUZpIszSBdnkC7OIF2cQbo4g3RxBuniDNLFGaSLM0gXZ5AuziBdnEG6OIN0cQbp4gzSxRmkizMuujj7ePkF+9geju7bdmHm6PPUsT+dzbWee24vfX5wz3o6ff+WZ07P85OX5bPD63nN7Rhr7odY8yLV8w9ZM46xZh5jzXGMNesYa/Yx1pzHWPMYt6BxjFvQOMYtqI5xC6pj3ILqa29Bf8qvj+ty/tmt2U+PnH2eepBTFzl1k1NPcuqVnHojp97FqXshpw5yarKNTbbxIvv0Oqcm29hkG5tsY5NtbLKNk2zjJNs4yTZOso0X2afXOTXZxkm2cZJtnGQbJ9nGlWzjSrZxJdu4km28yD69zqnJNq5kG1eyjSvZxpVs40a2cSPbuJFt3Mg2XmSfXufUZBs3so0b2caNbONGtnEn27iTbdzJNu5kGy+yT69zarKNO9nGnWzjTrZxF9tYi9jGWsQ21iK2sRaxjbWIbaxFbGMtYhtrEdtYi9jGWsg2BtnGINsYZBuDbONF9ul1Tk22Mcg2BtnGINsYZBuTbGOSbUyyjUm28SL79DqnJtuYZBuTbGOSbUyyjYNs4yDbOMg2DrKNX+0T/T1Tk20cZBsH2cZBtnGQbSyyjUW2kXRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxinRxmnRxmnRxmnRxmnRxehHb2KSL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SL06SLM0kXZ5IuziRdnEm6OHMR2zhJF2eSLs4kXZxJujiTdHEm6eJM0sWZpIszSRdnXnJx9rjwgsg9zlOPGl+84o+nT/+ScZ7n9Iv200Dbc4fH45Nrqcejua7n2fuvnX3b4mn2+fLsp/9+zvPhda4vH962vZ/+lnxx+GHTeZhN18Nsuh1m0/0om14Sgv5Bm8ZhNs3DbDoOs2kdYNPTJ/+//vHm+pv37z6e/sj99366/fbu5sPtw6d3P//w+3dOZ38F"},{"name":"_set_authorized","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"H4sIAAAAAAAC/+2ZW2/jRBTHJ2nSbZeSxE2auLm0bpts2tyzbdpduuUNxDtvvCBgYUHiInERgo/Ip2LOmTn+x3Xk1VkVq0JrybF95v+bcxk78Wn7ZsuYnbKxW8/4zV7tmIrZtocC7R8bObMnRbsXKqYgJqcr0c66ktvXdWwa0CDNXhz46cwWn5HQjW6R74GfxGyf2o/qykh4AX08qRpn2KYLP+Vun5Iw13bfG0gSTw0badujD6chtx/0MdI3hU/t8UMnfurFlUHRGU0FWMVp9twpo3/ALGiVURJUgVaBVj36M8yC1hglQQ1oDWjNo9/ALGjAKAkCoAHQwKO/wyzoPqMk2Ae6D3Tfoz/ALGidURLUgdaB1j36C8yCNhglQQNoA2jDHdNINRux3iKYBT1glAQHQA+AHnj0S5gFbTJKgibQJtCmR3+DWdAWoyRoAW0BbXn0W5gFDRklQQg0BBqmyxPG66hEDrIRG+BXMAt6yCgJDoEeAj1MezuMnwwlEmQjNsDvYRa0zSgJ2kDbQNtpb+34nsxArLdfYRa0wygJOkA7QDtpb5344clArLe/YRa0yygJukC7QLtpb934hspArLfXMAvaY5QEPaA9oL20t178vCmRmh4J9Ug1l1zqDx6YXZ8fYRb0iFESHAE9Anrk0b9gFvSYURIcAz0GepwO9DguRwZivX0Ns6ARoySIgEZAo7S3KL5tlUhDj9T0SKhHerkg71Cxbi5F3tcjVT0S5FKxdi65PNp77CgbOSF7B2/nNwwavJLLOzipzUDe0+2MJYPthF2dJF2dOjhypzJCr/+nEPXxlj/Y5tOB1z+zX0+kGBZYOCQT7Rxx6K4kXWKGA5GdwbEbKDojDYqHPh0j6n3WwroX8HXBZ3vjNDTNblybHdRmN9m5PEFOtqplk9y4UtyOccFO3DQ7fppoUyX9ou364HY3IaVsJBGSJLN3W1rT7LjfhPvx0nbq4qWqnLqmTopU6rM70y/zseRLe+acvOLyyywDVGyYrNgzhDe0E35uj+dYKxJfcJLndAbswmmG7nR9eYEEeqSuR9p6JMxGbBnewCzoiFESjICOgI7S3kbxF6cSaeiRph7p6ZG6HgkePH27PguYBR0zSoIx0DHQcdrbOPamRKp6pK5HglxyCfVILxfkLRWzd8GfMAs6YZQEE6AToJO0t0n8lCqRbjZiA5zBLOiUURJMgU6BTtPepvHSKpFzPRLokboeaeuRUI9c6JFWLuvS1CO9XNYlyCWXt1TMPjc/wSzojFESzIDOgM7S3mbx39OUSFOPBHqk8VgDC/VI+zFUzN4438Es6JxREsyBzoHO097mcU5KpK5HpnqkkY3YMixhFnTBKAkWQBdAF2lvi/inKgOhfqn4GfqOOwYNmg3pLha+D/Fssotdsqtl0tVzBy/cqYxQY/Mcoiv0LyvXxa68/tp3sTeui6X2mlrNa474E3cl6RJzMxDZJRy7gaIz0qB4uKJjZGe6XQvrXsDX0hbfofFbxrUpoTbLZE921l8f2XJaVx0OJdq4JEvveiNSzkYQ3yJuTJd+koVrO5e+7Sy7drNsXLsZIf3LTct+mUzteX99RO4kEl3FryxXa6vrNJe+4BuRQI/U9Uhbj4R65EKPtPRIQ4809Ugvl3UJckl/lIuX6v+oYmEuN0w+99g4l6eyq0cmuSzl++/k99/J//XqN3Op2FSPVHLJJXisN0yQyyPWfqwVm+WSSz2XO/kd0p8/+E8SNV9bb9A33DFoki2B8WrXLl66GdfbxRW7WiVd+Xbuyp3KyCvXCYroBfqPl65dfOn1H/l28da1i7dkop0jfu2uJF1ibgciu4FjN1B0RhoUDy/oGNnrL9bCuhcwt4uU7Z37nx/tZYS+isu0jTKtku1V1F8f2fKTrOLVKW9cnbifPS94go7LM3IY/kP7v2DEW1sFKwAA","debug_symbols":"5dzRblTHEoXhd/E1OtpVXdVVzascRZGTkMgSMlFwIkUo755xmLFBjGCWIME/+yoCeuxqKtLaLDbfm6ufXvzw+y/f39z+/Or11fP/v7l6+erH67ubV7eHH7252v5n+c/Pvv71+vb+J17fXf92d/V8e3b14vanw3//enb1883LF1fPM/969sGxiF7HkxGrHg73ucNz2unLzun57uHvnt1PMj9nkuHzNMkY+YlJIk9jz6gzk9TFk7w93+L5pZ33TTxv4nkXzw/xfIjnUzw/xfPifl3cr4v7HeJ+h7jfIe53iPsd4n6HuN8h7neI+x3ifoe43xD3G+J+Q9xviPsNcb8h7jfE/Ya43xD3G+J+U9xvivtNcb8p7jfF/aa43xT3m+J+U9xvivud4n6nuN8p7neK+53ifqe43ynud4r7neJ+p7jfEvdb4n5L3G+J+y1xvyXut8T9lrjfEvdb4n5b3G+L+21xvy3ut8X9trjfFvfb4n5b3G+L+13ifpe43yXud4n7XeJ+l7jfJe53iftd4n6XuF/bNvUDpn7A1Q8M9QOhfiDVD0z1A2rPsalFx6Zu2tRNm7ppUzdt6qZN3bSpmzZ103KjJVdaaqdlaqllaqtlaq1laq9larFlarNlarVlardlarllartlar1lar9lasFlasNlasVlasdlasllastlas1las9latFlatNlatVlatdlatllattlat1lat9lauFlauNlauVlaudlaullautlau1lau9lavFlavNlavVlavdlavllavtlav1lav9lagFmagNmagVmagdmaglmagtmag1mag9mahFmahNmahVmahdmahlmahtmah1mah9maiFmaiNmaiVmaidmailmaitmai1mLb83oG5abcZMrcZM7cZMLcdMbcdMrcdM7cdMLchMbchsya+IyO+IqC+JqB2Zqx2Zqx2Zqx2Zqx2Zqx2Zqx2Zqx2Zqx2Zm/w6kLpptSNztSNztSNztSNztSNztSNztSNz+b0v+cUv/c0vddPyu1/yy1/y21/y61/y+1/yC2BqR+ZqR+ZqR+ZDfslP3bTakbnakbnakbnakbnakbnakbnakbnakbnakXnI73Oqm1Y7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mlc7Mp/yW9rqptWOzNWOzNWOzNWOzNWOzNWOzNWOzNWOzNWOzEt+IV/dtNqRudqRudqRudqRudqR+fmObHTn8TNjub/7sQ//6csafTy7uh+OHv6i4szZw1/yHM8e6ouHs4f/fc593dxOQ6yc8Xj6/rucOX36xzq2be8crtNFYy8Xzb1cdO7lorWXi/ZOLnq+Qv8WL2p7uajv5aJ7eWBYe3lgWHt5YFh7eWBYe3lgWLt5YFj7uOjYdvJkNLbPfzKybY7T9zDfPnHVsyXAh8dy2fHg3N7/3TvOPaBzB3TuhM49oXMXdO6Gzr2Yc9sGnRuaO+bQuaF5adC8NGheGjQvDZqXBs1Lg+alQ/PSoXnp0Lx0aF46NC8dmpcOzUuH5qVD89KheTmgeTmgeTmgeTmgeTmgeTmgeTmgeTmgeTmgeTmgeRnQvAxoXgY0LwOalwHNy4DmZUDzMqB5GdC8DGheJjQvE5qXCc3LhOZlQvMyoXmZ0LxMaF4mNC8TmpcTmpcTmpcTmpcTmpcTmpcTmpcTmpcTmpcTmpcTmpcFzcuC5mVB87KgeVnQvCxoXhY0LwualwXNy4LmZUPzsqF52dC8bGhefgF/6evMDc3LhuZlQ/OyoXnZ0Lxc0Lxc0Lxc0Lxc0Lz8AvzQ15kbmpcLmpcLmpcLmpeLmZexMfMyoE5ObMy8DKjvExszLwPq+wTU9wmo7xNQ3yegvk9AfZ+A+j4B9X0C6vsE1PcJqO8TUN8noL5PQH2fgPo+AfV9Aur7BNT3CajvE1DfJ6C+T0B9n4D6PgH1fQLq+wTU9wmo7xNQ3yegvk9AfZ+A+j4B9X0C6vsE1PcJqO8TUN8noL5PQH2fgPo+AfV9Aur7BNT3CajvE1DfJ6C+T0B9n4D6PgH1fQLq+wTU9wmo7xNQ3yegvk9AfZ+A+j4B9X0C6vsE1PcJqO8TUN8noL5PQH2fgPo+AfV9Aur7BNT3CajvE1DfJ6C+T0B9n4D6PgH1fQLq+wTU9wmo7xNQ3yegvk9AfZ+A+j4B9X0C6vsE1PcJqO8TUN8noL5PQH2fgPo+AfV9Aur7BNT3CajvE1DfJ6C+T0B9n4D6Pgn1fRLq+yTU90mo75MbMy8T6vsk1PdJqO+TUN8nob5PQn2fhPo+CfV9Eur7JNT3Sajvk1DfJ6G+T0J9n4T6Pgn1fRLq+yTU90mo75NQ3yehvk9CfZ+E+j4J9X0S6vsk1PdJqO+TUN8nob5PQn2fhPo+CfV9Eur7JNT3Sajvk1DfJ6G+T0J9n4T6Pgn1fRLq+yTU90mo75NQ3yehvk9CfZ+E+j4J9X0S6vsk1PdJqO+TUN8nob5PQn2fhPo+CfV9Eur7JNT3Sajvk1DfJ6G+T0J9n4T6Pgn1fRLq+yTU90mo75NQ3yehvk9CfZ+E+j4J9X0S6vsk1PdJqO+TUN8nob5PQn2fhPo+eYHvM9bHv8UafTy7uj8xteVpbluPZ73i3NfN7TTEOvw5+PH0/Xc5c3qevvK2vXO4ThfNvVx07uWitZeL9l4uunZy0QsUpG/koraXi/peLjr2ctHYy0X38mS09vJktPbyZLT28mS0Pv/J6F/542Vtp9+98nz8kjPfzj23DTq3Qed26NwDOndA507o3BM6d0Hnbujc0Lw0aF4aNC8NmpcGzcsL+KqnOTc0Lw2alwbNS4PmpUHz0qF56dC8dGheOjQvL+Crnubc0Lx0aF46NC8dmpcOzcsBzcsBzcsBzcsBzcsL+KqnOTc0Lwc0Lwc0Lwc0Lwc0LwOalwHNy4DmZUDz8gK+6mnODc3LgOZlQPMyoHkZ0LxMaF4mNC8TmpcJzcsL+KqnOTc0LxOalwnNy4TmZULzckLzckLzckLzckLz8gK+6mnODc3LCc3LCc3LCc3LCc3LguZlQfOyoHlZ0Ly8gK96mnND87KgeVnQvCxoXhY0Lxualw3Ny4bmZUPz8gvwVV9nbmheNjQvG5qXDc3LhublgublgublgublgublF0CNvs7c0Lxc0Lxc0Lxc0LyE+j4F9X0K6vsU1PcpqO9TGzMvC+r7FNT3KajvU1Dfp6C+T0F9n4L6PgX1fQrq+xTU9ymo71NQ36egvk9BfZ+C+j4F9X0K6vsU1PcpqO9TUN+noL5PQX2fgvo+BfV9Cur7FNT3KajvU1Dfp6C+T0F9n4L6PgX1fQrq+xTU9ymo71NQ36egvk9BfZ+C+j4F9X0K6vsU1PcpqO9TUN+noL5PQX2fgvo+BfV9Cur7FNT3KajvU1Dfp6C+T0F9n4L6PgX1fQrq+xTU9ymo71NQ36egvk9BfZ+C+j4F9X0K6vsU1PcpqO9TUN+noL5PQX2fgvo+BfV9Cur7FNT3KajvU1Dfp6C+T0F9n4L6PgX1fQrq+xTU9ymo71NQ36egvk9BfZ+C+j4F9X0K6vsU1PcpqO9TUN+noL5PQX2fgvo+DfV9Gur7NNT3aajv0xszLxvq+zTU92mo79NQ36ehvk9DfZ+G+j4N9X0a6vs01PdpqO/TUN+nob5PQ32fhvo+DfV9Gur7NNT3aajv01Dfp6G+T0N9n4b6Pg31fRrq+zTU92mo79NQ36ehvk9DfZ+G+j4N9X0a6vs01PdpqO/TUN+nob5PQ32fhvo+DfV9Gur7NNT3aajv01Dfp6G+T0N9n4b6Pg31fRrq+zTU92mo79NQ36ehvk9DfZ+G+j4N9X0a6vs01PdpqO/TUN+nob5PQ32fhvo+DfV9Gur7NNT36Qt8n/tv/9G5fdlp7hHjvW/y4elcdpoo13gcqc8dHg9fObZ4OOpVp+n9v56+2x6nnx+fPmv46XDN+vjh7nUautd47/DxrmNHd40d3TV3dNe5o7vWju7aO7rr2s9dL1CYvp272i7uevjBH9e/3Vz/8PLF68NH7n/t99sf725e3R5/ePfnr29/5XD2bw=="}],"outputs":{"globals":{"storage":[{"fields":[{"name":"reject_all","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"approved_actions","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"reject","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_reject_all_parameters"}}],"kind":"struct","path":"AuthRegistry::set_reject_all_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_authorized_private_parameters"}}],"kind":"struct","path":"AuthRegistry::set_authorized_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::is_consumable_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::is_consumable_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::_set_authorized_parameters"}}],"kind":"struct","path":"AuthRegistry::_set_authorized_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::consume_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::consume_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AuthRegistry::is_reject_all_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::is_reject_all_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_authorized_parameters"}}],"kind":"struct","path":"AuthRegistry::set_authorized_abi"}]}},"file_map":{"112":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n"},"115":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n"},"117":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<let N: u32>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"119":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n"},"120":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<let N: u32>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"122":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"143":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"156":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{hash::pedersen_hash, storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"165":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"173":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr","source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"176":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n"},"177":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr","source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x065f2831db9ac0db5e710bd3a865b5facd8cf83f1585e1af8fd1d6ce9c47f685;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"179":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS, FIXED_L2_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: FIXED_L2_GAS }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n"},"181":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"182":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr","source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    note_hashes: u32,\n    nullifiers: u32,\n    l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            note_hashes: validate_array(public_inputs.note_hashes),\n            nullifiers: validate_array(public_inputs.nullifiers),\n            l2_to_l1_msgs: validate_array(public_inputs.l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    note_hashes: [NoteHash; MAX_NOTE_HASHES_PER_CALL],\n    nullifiers: [Nullifier; MAX_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs: [L2ToL1Message; MAX_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.note_hashes == other.note_hashes) &\n        (self.nullifiers == other.nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.l2_to_l1_msgs == other.l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.note_hashes.len() {\n            fields.extend_from_array(self.note_hashes[i].serialize());\n        }\n        for i in 0..self.nullifiers.len() {\n            fields.extend_from_array(self.nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL]),\n            nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            note_hashes: [NoteHash::empty(); MAX_NOTE_HASHES_PER_CALL],\n            nullifiers: [Nullifier::empty(); MAX_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x15c9b0a92b9b541598e24c9f0b0b4b04b7f2408599751c45aa12de671fd9b363;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"183":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr","source":"use crate::{\n    abis::{\n    private_call_stack_item::PrivateCallStackItem, call_context::CallContext,\n    function_data::FunctionData, caller_context::CallerContext,\n    side_effect::{Ordered, RangeOrdered, Scoped}\n},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    target: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.target == other.target) \n            & (self.call_context == other.call_context) \n            & (self.function_data == other.function_data) \n            & (self.args_hash == other.args_hash) \n            & (self.returns_hash == other.returns_hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            target: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.target.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            target: reader.read_struct(AztecAddress::deserialize),\n            call_context: reader.read_struct(CallContext::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n\n    pub fn matches_stack_item(self, stack_item: PrivateCallStackItem) -> bool {\n        (self.target == stack_item.contract_address)\n            & (self.call_context == stack_item.public_inputs.call_context)\n            & (self.function_data == stack_item.function_data)\n            & (self.args_hash == stack_item.public_inputs.args_hash)\n            & (self.returns_hash == stack_item.public_inputs.returns_hash)\n            & (self.start_side_effect_counter\n                                == stack_item.public_inputs.start_side_effect_counter)\n            & (self.end_side_effect_counter\n                                    == stack_item.public_inputs.end_side_effect_counter)\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"186":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n}\n// docs:end:call-context\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n"},"202":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"204":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"206":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr","source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"210":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"212":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr","source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n"},"213":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr","source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> Self {\n        // Hide the counter when exposing to public.\n        Self {\n            log_hash: LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length },\n            contract_address: self.contract_address\n        }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n"},"215":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr","source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"216":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr","source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"217":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item_compressed.nr","source":"use crate::abis::{call_context::CallContext, function_data::FunctionData, gas::Gas};\nuse crate::address::AztecAddress;\nuse crate::constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH};\nuse crate::traits::{Hash, Empty, Serialize, Deserialize};\nuse crate::utils::reader::Reader;\n\n/**\n * A compressed version of the PublicCallStackItem struct used to compute the \"hash\"\n * of a PublicCallStackItem.\n * \n * Historically, we have been zeroing most values in the PublicCallStackItem struct\n * to compute the hash involved when adding a PublicCallStackItem to the PublicCallStack.\n * \n * This struct is used to store the values that we did not zero out, and allow us to hash\n * only these, thereby skipping a lot of computation and saving us a lot of constraints\n * \n * Essentially this struct exists such that we don't have a `hash` function in the \n * PublicCallStackItem struct that practically throws away some values of the struct\n * without clearly indicating that it does so.\n */\nstruct PublicCallStackItemCompressed {\n    contract_address: AztecAddress,\n    call_context: CallContext,\n    function_data: FunctionData,\n    args_hash: Field,\n    returns_hash: Field,\n    revert_code: u8,\n    start_gas_left: Gas,\n    end_gas_left: Gas,\n}\n\nimpl Eq for PublicCallStackItemCompressed {\n    fn eq(self, other: PublicCallStackItemCompressed) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.call_context == other.call_context)\n            & (self.function_data == other.function_data)\n            & (self.args_hash == other.args_hash)\n            & (self.returns_hash == other.returns_hash)\n            & (self.revert_code == other.revert_code)\n            & (self.start_gas_left == other.start_gas_left)\n            & (self.end_gas_left == other.end_gas_left)\n    }\n}\n\nimpl Hash for PublicCallStackItemCompressed {\n    fn hash(self) -> Field {\n        std::hash::pedersen_hash_with_separator(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PublicCallStackItemCompressed {\n    fn empty() -> Self {\n        PublicCallStackItemCompressed {\n            contract_address: AztecAddress::empty(),\n            call_context: CallContext::empty(),\n            function_data: FunctionData::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n        }\n    }\n}\n\nimpl Serialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n    fn serialize(self) -> [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.call_context.serialize());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n\n        assert_eq(fields.len(), PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH> for PublicCallStackItemCompressed {\n  fn deserialize(fields: [Field; PUBLIC_CALL_STACK_ITEM_COMPRESSED_LENGTH]) -> PublicCallStackItemCompressed {\n    let mut reader = Reader::new(fields);\n\n    let item = PublicCallStackItemCompressed {\n      contract_address: reader.read_struct(AztecAddress::deserialize),\n      call_context: reader.read_struct(CallContext::deserialize),\n      function_data: reader.read_struct(FunctionData::deserialize),\n      args_hash: reader.read(),\n      returns_hash: reader.read(),\n      revert_code: reader.read() as u8,\n      start_gas_left: reader.read_struct(Gas::deserialize),\n      end_gas_left: reader.read_struct(Gas::deserialize),\n    };\n    reader.finish();\n    item\n  }\n}\n"},"221":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"223":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"224":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr","source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"229":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr","source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"231":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/header.nr","source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n"},"24":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"27":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constraint the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::from_slice(domain_generators.as_slice());\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = crate::field::bn254::decompose_hint(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"270":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"272":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"274":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n"},"277":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"278":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n"},"279":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr","source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n"},"281":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"285":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"288":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"295":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr","source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"296":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr","source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n"},"55":{"path":"/Users/admin/Documents/token_prototype_aztec/aztec-starter/src/main.nr","source":"contract AuthRegistry {\n    use dep::aztec::{state_vars::{PublicMutable, Map}, \nprotocol_types::address::AztecAddress};\n    use dep::authwit::auth::{IS_VALID_SELECTOR, \ncompute_authwit_message_hash, assert_current_call_valid_authwit};\n\n    #[aztec(storage)]\n    struct Storage {\n      reject_all: Map<AztecAddress, PublicMutable<bool>>,\n      // on_behalf_of => authwit hash => authorized\n      approved_actions: Map<AztecAddress, Map<Field, \nPublicMutable<bool>>>,\n    }\n\n    /**\n     * Updates the `authorized` value for `msg_sender` for `message_hash`.\n     *\n     * @param message_hash The message hash being authorized\n     * @param authorize True if the caller is authorized to perform the \nmessage hash, false otherwise\n     */\n    #[aztec(public)]\n    fn set_authorized(message_hash: Field, authorize: bool) {\n        \nstorage.approved_actions.at(context.msg_sender()).at(message_hash).write(authorize);\n    }\n\n    /**\n     * Updates the `reject_all` value for `msg_sender`.\n     * \n     * When `reject_all` is `true` any `consume` on `msg_sender` will \nrevert.\n     * \n     * @param reject True if all actions should be rejected, false \notherwise\n     */\n    #[aztec(public)]\n    fn set_reject_all(reject: bool) {\n        storage.reject_all.at(context.msg_sender()).write(reject);\n    }\n\n    /**\n     * Consumes an `inner_hash` on behalf of `on_behalf_of` if the caller \nis authorized to do so.\n     * \n     * Will revert even if the caller is authorized if `reject_all` is set \nto true for `on_behalf_of`.\n     * This is to support \"mass-revoke\".\n     *\n     * @param on_behalf_of The address on whose behalf the action is being \nconsumed\n     * @param inner_hash The inner_hash of the authwit\n     * @return `IS_VALID_SELECTOR` if the action was consumed, revert \notherwise\n     */\n    #[aztec(public)]\n    fn consume(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n        assert_eq(false, storage.reject_all.at(on_behalf_of).read(), \n\"rejecting all\");\n\n        let message_hash = compute_authwit_message_hash(\n            context.msg_sender(),\n            context.chain_id(),\n            context.version(),\n            inner_hash\n        );\n\n        let authorized = \nstorage.approved_actions.at(on_behalf_of).at(message_hash).read();\n\n        assert_eq(true, authorized, \"unauthorized\");\n        \nstorage.approved_actions.at(on_behalf_of).at(message_hash).write(false);\n\n        IS_VALID_SELECTOR\n    }\n\n    /**\n     * Updates a public authwit using a private authwit\n     * \n     * Useful for the case where you want someone else to insert a public \nauthwit for you.\n     * For example, if Alice wants Bob to insert an authwit in public, \nsuch that they can execute\n     * a trade, Alice can create a private authwit, and Bob can call this \nfunction with it.\n     *\n     * @param approver The address of the approver (Alice in the example)\n     * @param message_hash The message hash to authorize\n     * @param authorize True if the message hash should be authorized, \nfalse otherwise\n     */\n    #[aztec(private)]\n    fn set_authorized_private(approver: AztecAddress, message_hash: Field, \nauthorize: bool) {\n        assert_current_call_valid_authwit(&mut context, approver);\n        AuthRegistry::at(context.this_address())._set_authorized(approver, \nmessage_hash, authorize).enqueue(&mut context);\n    }\n\n    /**\n     * Internal function to update the `authorized` value for `approver` \nfor `messageHash`.\n     * Used along with `set_authorized_private` to update the public \nauthwit.\n     * \n     * @param approver The address of the approver\n     * @param message_hash The message hash being authorized\n     * @param authorize True if the caller is authorized to perform the \nmessage hash, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _set_authorized(approver: AztecAddress, message_hash: Field, \nauthorize: bool) {\n        \nstorage.approved_actions.at(approver).at(message_hash).write(authorize);\n    }\n\n    /**\n     * Fetches the `reject_all` value for `on_behalf_of`.\n     * \n     * @param on_behalf_of The address to check\n     * @return True if all actions are rejected, false otherwise\n     */\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_reject_all(on_behalf_of: AztecAddress) -> bool {\n        storage.reject_all.at(on_behalf_of).read()\n    }\n\n    /**\n     * Fetches the `authorized` value for `on_behalf_of` for \n`message_hash`.\n     * \n     * @param on_behalf_of The address on whose behalf the action is being \nconsumed\n     * @param message_hash The message hash to check\n     * @return True if the caller is authorized to perform the action, \nfalse otherwise\n     */\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> \nbool {\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n\n    unconstrained fn unconstrained_is_consumable(on_behalf_of: \nAztecAddress, message_hash: Field) -> pub bool {\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n}\n"},"58":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::pedersen_hash\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties \n * (e.g. protocols or other users) to execute an action on their behalf.\n * \n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be \n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few \n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can \n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be \n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n * \n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer. \n * \n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is \n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n * \n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline \n * how this would look in private, and then in public later. \n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX). \n * `Alice` would make a `deposit` transaction, that she is executing using her account contract. \n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token` \n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to \n * convince the `Token` contract that it is allowed to do so. \n * \n * This is where the authentication witness comes in! The `Token` contract computes a `message_hash` from the \n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to \n * execute that call.\n * \n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her \n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n * \n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n * \n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts. \n * \n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *  \n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store \n * the messages that we have approved. \n * \n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `keccak256(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a colission and we return \n *      a success flag.\n * \n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be \n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the \n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n * \n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains. \n */\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n/** \n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/** \n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n * \n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n * \n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize  \n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\"),\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier, 0);\n}\n\n/** \n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/** \n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"consume((Field),Field)\"),\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness \n * \n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n * \n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n * \n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n * \n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    pedersen_hash(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/** \n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n * \n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n * \n * @param on_behalf_of The address that have authorized the the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n * \n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n * \n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n * \n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\"),\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n * \n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise \n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        AztecAddress::from_field(CANONICAL_AUTH_REGISTRY_ADDRESS),\n        FunctionSelector::from_signature(\"set_reject_all(bool)\"),\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"79":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"83":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"84":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::{raw_storage_read, storage_read}\n};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"},"85":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"},"86":{"path":"/Users/admin/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            target: item.contract_address,\n            call_context: item.public_inputs.call_context,\n            function_data: item.function_data,\n            args_hash: item.public_inputs.args_hash,\n            returns_hash: item.public_inputs.returns_hash,\n            caller_context,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.get_compressed().hash());\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.get_compressed().hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}